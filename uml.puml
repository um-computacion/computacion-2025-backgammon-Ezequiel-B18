// UML DIAGRAM ALT+D to run

@startuml Diagrama de clases
package core {
  class Board {
    - points: list[(player:int,count:int)]
    - bar: dict[int,int]
    - home: dict[int,int]
    + __init__(test_bearing_off=False)
    + setup_starting_positions()
    + get_player_at_point(point:int): int
    + get_checkers_count(point:int): int
    + is_valid_move(player:int, from_point:int, to_point:int): bool
    + move_checker(player:int, from_point:int, to_point:int): dict
    + enter_from_bar(player:int, point:int): bool
    + all_checkers_in_home_board(player:int): bool
    + bear_off(player:int, point:int): bool
    + check_winner(): int
  }

  enum CheckerColor
  enum CheckerState {
    ON_BOARD
    ON_BAR
    BORNE_OFF
  }

  class Checker {
    - color: CheckerColor
    - state: CheckerState
    - position: int | None
    + __init__(color: CheckerColor)
    + set_position(position:int)
    + move_to_position(new_position:int)
    + calculate_new_position(dice_value:int): int
    + send_to_bar()
    + enter_from_bar(position:int)
    + bear_off()
    + is_in_home_board(): bool
    + can_bear_off_with_value(dice_value:int): bool
    + __str__(): str
  }

  class Dice {
    - values: list[int]
    - initial_values: list[int]
    + __init__()
    + roll(): list[int]
    + is_doubles(): bool
    + get_moves(): list[int]
    + initial_roll(): tuple
    + is_initial_tie(): bool
    + get_highest_roller(): int
  }

  enum PlayerColor

  class Player {
    - name: str
    - color: PlayerColor
    - player_id: int
    - checkers: list[Checker]
    - is_turn: bool
    - remaining_moves: int
    + __init__(name:str, color:PlayerColor)
    + get_starting_positions(): list[(point:int,count:int)]
    + distribute_checkers(board:Board)
    + start_turn(dice:Dice)
    + end_turn()
    + use_move(): bool
    + get_checkers_by_state(state:CheckerState): list[Checker]
    + count_checkers_by_state(state:CheckerState): int
    + has_checkers_on_bar(): bool
    + has_won(): bool
    + __str__(): str
  }

  class Game {
    - board: Board
    - dice: Dice
    - player1: Player
    - player2: Player
    - current_player: Player | None
    - other_player: Player | None
    + __init__(player1_name:str="White", player2_name:str="Black", test_bearing_off:bool=False)
    + setup_game()
    + sync_checkers()
    + initial_roll_until_decided(): int
    + start_turn()
    + apply_move(from_point:int, to_point:int): bool
    + switch_players()
    + is_game_over(): bool
    + get_winner(): Player | None
  }
}

' Relationships
Game --> Board : usa API de Board (mutaciones hechas por Game)
Game --> Dice : solicita tiradas
Game --> Player : coordina jugadores
Player "1" *-- "15" Checker : posee 15 fichas
Board ..> Checker : fuente única de verdad (SSoT)
Board ..> Player : informa (vía Game.sync_checkers)
Dice ..> Game : suministra tiradas

' Nota SSoT más explícita (mejor explicación en español)
note top of Board
  SSoT = "Single Source of Truth" para el estado del tablero:
  - Board mantiene: points (ocupación por punto), bar (fichas en la barra), home (fichas borne-off).
  - Solo Board debe mutar estos campos. Las mutaciones se realizan mediante sus metodos:
    p.ej. Board.move_checker(...), Board.enter_from_bar(...), Board.bear_off(...).
  - Game es el componente autorizado para invocar esos metodos y coordinar la actualización:
    1) Game llama a Board.move_checker(...) (Board muta el estado).
    2) Game.sync_checkers() lee Board y actualiza Player.checkers para que reflejen la SSoT.
  - Otros componentes (UI/tests) deben leer desde Board o desde Player tras la sincronización; evitar que Player modifique Board directamente.
end note
@enduml